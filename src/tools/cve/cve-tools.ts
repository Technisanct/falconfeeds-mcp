import { z } from "zod";
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ICVEService } from "../../services/cve/cve-service.js";
import { FalconFeedsApiError } from "../../services/api-client.js";

export function registerCVETools(server: McpServer, cveService: ICVEService): void {
  server.registerTool(
    "search_cves",
    {
      description: "Search for CVEs with various filters including ID, keyword, and date range",
      inputSchema: {
        cveID: z.string().optional().describe("Specific CVE ID to search for (e.g., CVE-2021-44228)"),
        keyword: z.string().optional().describe("Keyword for full-text search"),
        publishedSince: z.number().optional().describe("Start date in milliseconds"),
        publishedTill: z.number().optional().describe("End date in milliseconds"),
        resultCount: z.number().min(1).max(50).default(10).describe("Number of results (1-50)"),
        next: z.string().optional().describe("Pagination token for next page")
      }
    },
    async ({ cveID, keyword, publishedSince, publishedTill, resultCount = 10, next }) => {
      try {
        const response = await cveService.searchCVEs({
          cveID,
          keyword,
          publishedSince,
          publishedTill,
          resultCount,
          next
        });

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(response, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof FalconFeedsApiError) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message} (Status: ${error.status}, Code: ${error.code})`
              }
            ],
            isError: true
          };
        }
        throw error;
      }
    }
  );

  server.registerTool(
    "get_cve_by_id",
    {
      description: "Get a specific CVE by its ID",
      inputSchema: {
        cveId: z.string().describe("CVE ID (e.g., CVE-2021-44228)"),
        resultCount: z.number().min(1).max(50).default(10).describe("Number of results (1-50)")
      }
    },
    async ({ cveId, resultCount = 10 }) => {
      try {
        const response = await cveService.getCVEById(cveId, resultCount);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(response, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof FalconFeedsApiError) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message} (Status: ${error.status}, Code: ${error.code})`
              }
            ],
            isError: true
          };
        }
        throw error;
      }
    }
  );

  server.registerTool(
    "search_cves_by_keyword",
    {
      description: "Search CVEs by keyword in descriptions and titles",
      inputSchema: {
        keyword: z.string().describe("Keyword to search for in CVE descriptions"),
        resultCount: z.number().min(1).max(50).default(10).describe("Number of results (1-50)")
      }
    },
    async ({ keyword, resultCount = 10 }) => {
      try {
        const response = await cveService.searchCVEsByKeyword(keyword, resultCount);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(response, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof FalconFeedsApiError) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message} (Status: ${error.status}, Code: ${error.code})`
              }
            ],
            isError: true
          };
        }
        throw error;
      }
    }
  );

  server.registerTool(
    "get_cves_by_date_range",
    {
      description: "Get CVEs published within a specific date range",
      inputSchema: {
        publishedSince: z.number().describe("Start date in milliseconds"),
        publishedTill: z.number().describe("End date in milliseconds"),
        resultCount: z.number().min(1).max(50).default(10).describe("Number of results (1-50)")
      }
    },
    async ({ publishedSince, publishedTill, resultCount = 10 }) => {
      try {
        const response = await cveService.getCVEsByDateRange(
          publishedSince,
          publishedTill,
          resultCount
        );

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(response, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof FalconFeedsApiError) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message} (Status: ${error.status}, Code: ${error.code})`
              }
            ],
            isError: true
          };
        }
        throw error;
      }
    }
  );

  server.registerTool(
    "get_next_cve_page",
    {
      description: "Get the next page of CVE results using pagination token",
      inputSchema: {
        nextToken: z.string().describe("Pagination token from previous response"),
        resultCount: z.number().min(1).max(50).default(10).describe("Number of results (1-50)")
      }
    },
    async ({ nextToken, resultCount = 10 }) => {
      try {
        const response = await cveService.getNextPage(nextToken, resultCount);

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(response, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof FalconFeedsApiError) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message} (Status: ${error.status}, Code: ${error.code})`
              }
            ],
            isError: true
          };
        }
        throw error;
      }
    }
  );
} 